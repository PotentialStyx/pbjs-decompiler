use anyhow::{format_err, Result};
use clap::Parser;
use serde::Deserialize;
use std::{collections::HashMap, fs, thread, time::SystemTime};

/// Program to decompile protobuf code generated by protobuf.js
#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    // TODO: support this
    // #[arg(long, default_value = "@replit/protocol")]
    // package: String,
    #[arg(short = 'v', long, default_value = "latest")]
    package_version: String,

    #[arg(short, long, default_value = "out.proto")]
    outfile: String,
}

mod decoder;
mod parser;
mod reconstruct;

#[derive(Deserialize, Debug, Clone)]
struct DistTag {
    latest: String,
}

// #[derive(Deserialize, Debug, Clone)]
// struct Dist {
//     tarball: String,
// }

#[derive(Deserialize, Debug, Clone)]
struct Version {
    //     dist: Dist,
}

#[derive(Deserialize, Debug, Clone)]
#[serde(rename_all = "kebab-case")]
struct Package {
    dist_tags: DistTag,
    versions: HashMap<String, Version>,
}

#[derive(Deserialize, Debug, Clone)]
struct File {
    // size: i32,
    hex: String,
}

#[derive(Deserialize, Debug, Clone)]
struct Index {
    files: HashMap<String, File>,
}

fn main() -> Result<()> {
    let args = Args::parse();

    let package_name = "@replit/protocol";
    let start = SystemTime::now();
    let package = reqwest::blocking::get(format!("https://registry.npmjs.org/{package_name}"))?
        .json::<Package>()?;

    let version = if args.package_version == "latest" {
        package.dist_tags.latest
    } else if package.versions.contains_key(&args.package_version) {
        args.package_version
    } else {
        return Err(format_err!(
            "{} is not a version for https://npm.im/{package_name}",
            args.package_version
        ));
    };

    let index = reqwest::blocking::get(format!(
        "https://www.npmjs.com/package/{package_name}/v/{}/index",
        version
    ))?
    .json::<Index>()?;
    println!(
        "ðŸ“¦ Fetched package metadata in {}ms",
        SystemTime::now().duration_since(start)?.as_millis()
    );

    let start = SystemTime::now();
    let mut ts_def: String = String::new();
    let mut js_code: String = String::new();
    thread::scope(|s| {
        s.spawn(|| {
            let url = format!(
                "https://www.npmjs.com/package/{package_name}/file/{}",
                index.files.get("/main/index.d.ts").unwrap().hex
            );
            let _ts_def = reqwest::blocking::get(url).unwrap().text().unwrap();

            let ts_syntax = biome_js_syntax::JsFileSource::d_ts();
            let ts_tree = biome_js_parser::parse(
                &_ts_def,
                ts_syntax,
                biome_js_parser::JsParserOptions::default(),
            );
            let ts_options = biome_js_formatter::context::JsFormatOptions::new(ts_syntax);
            ts_def = biome_js_formatter::format_node(ts_options.clone(), &ts_tree.syntax())
                .unwrap()
                .print()
                .unwrap()
                .into_code();
        });
        s.spawn(|| {
            let url = format!(
                "https://www.npmjs.com/package/{package_name}/file/{}",
                index.files.get("/main/index.js").unwrap().hex
            );
            let _js_code = reqwest::blocking::get(url).unwrap().text().unwrap();

            let js_syntax = biome_js_syntax::JsFileSource::js_script();
            let js_tree = biome_js_parser::parse(
                &_js_code,
                js_syntax,
                biome_js_parser::JsParserOptions::default(),
            );

            let js_options = biome_js_formatter::context::JsFormatOptions::new(js_syntax);
            js_code = biome_js_formatter::format_node(js_options.clone(), &js_tree.syntax())
                .unwrap()
                .print()
                .unwrap()
                .into_code();
        });
    });

    println!(
        "ðŸ’¾ Downloaded and formatted package code in {}ms",
        SystemTime::now().duration_since(start)?.as_millis()
    );

    let start = SystemTime::now();
    let output = decoder::decode(ts_def, js_code, version)?;
    fs::write(&args.outfile, output)?;
    println!(
        "ðŸª„ Decompiled to `{}` in {}ms",
        args.outfile,
        SystemTime::now().duration_since(start)?.as_millis()
    );
    Ok(())
}
